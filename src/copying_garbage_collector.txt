Copying garbage collectors work by allocating two regions of memory. Allocation is done in one region and when there is not enough space for an allocation all objects used by the program are marked. If the second region doesn't have enough memory for all the marked objects a bigger region is allocated and then the marked objects are copied to the second region. Then copying can be implemented by just swaping the regions and reseting the allocation linked list and then just allocating memory and copying the objects to it. When an object is copied, inside its allocation header a field specifying the new location of the object is set so the object is only copied once. In the end all the pointers in the roots get updated to the new locations. The allocation is very cheap becuase it  only requires a simple pointer bump and appending the object to a linked list. Then linked list can be stored inside the object's allocation header. This can probably be made even faster by using multiple threads for copying. Appending to a linked list and addition can both be implemented using atomic operations. On x86 these operations should be lock free. The GC pauses may be long becuase all the alive objects have to be copied to the other region. This can be made faster by making the GC generational which would create regions for different generations of objects. If an object has survived through enough GC runs it gets moved to the older generation which doesn't get GCed as often as the younger one. Allocating constants can be optimized by allocating them using a different allocator and setting their new location field to point to the object itself. The new location field can be reused for storing if the objects is marked for example using address 0 to specify an unmarked objects and address 1 to specify a marked one. Then to check if an object is marked the GC can check if the new location is not equal to 0. This will work even with objects that already got copied and have an updated new location field. Pointers to locations allocated by the GC are also not stable so for example creating a c++ style iterator for a statically sized array would require storing an array and an index instead of just storing the pointer to the element. Another issue is that if a c++ function that takes an argument that points to memory owned by the GC and then it allocates memory from the GC then that allocation might trigger the GC and the object that is in the function arguments would still point to the old version of the argument. One way to deal with this issue is to make the allocation function return if the GC run during the allocation and if so just retry the operation. A different way to make it work is to let the GC manage the function arguments by putting the at some root location for example the stack. The issue with this solution is that if the function c++ is for example an insert function into a hash table then if the hash table is inside the GC object then the function would also need to take in the offset of the hash table into the GC object. A simpler but slower way to make it work would be to just provide a way for the language to dynamically allocate a staticallly sized array and just implement the hash table in the language. If the hash table is used for field access then the operator can be overloaded and the class that defines this operation would be the base class of all the other classes. A different solution would to only allow the access of GCed objects throught a special class that would register itself to the GC. This only works for local variables. This class would a space overhead, becuase it would need to store the alloator it uses. If the allocator is global this wouldn't be an issue. It could be named Local. Because there are 2 main phases to the collector each user defined type has to define both a mark and an update functions and has to be cereful to register and update all the objects it owns. For updating references to objects pointers that are stable the GC could just get all the locations to update during the marking phase. This doesn't work for more complex types like hash tables or arrays. I don't think a copying collector is a good choice for a language that wants to make it easy for the user to define new types and functions using an FFI becuase both updating and marking objects is very error prone. The v8 engine uses a copying garbage collector so if I wanted to use a copying GC it would probably be a good example how to make an FFI for a language like that.